/** VecMem project, part of the ACTS project (R&D line)
 *
 * (c) 2021 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// Local include(s).
#include "vecmem/containers/array.hpp"
#include "vecmem/containers/const_device_array.hpp"
#include "vecmem/containers/const_device_vector.hpp"
#include "vecmem/containers/device_vector.hpp"
#include "vecmem/containers/vector.hpp"
#include "vecmem/memory/sycl/shared_memory_resource.hpp"
#include "../../sycl/src/utils/sycl/device_selector.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// System include(s).
#include <cassert>
#include <iostream>

/// Helper function for creating an "input vector".
vecmem::vector< int > make_input_vector( vecmem::memory_resource& resource ) {

   return { { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, &resource };
}

/// Helper function for creating an "output vector".
vecmem::vector< int > make_output_vector( vecmem::memory_resource& resource ) {

   return vecmem::vector< int >( 10, &resource );
}

int main() {

   // Create the SYCL queue that we'll be using in the test.
   cl::sycl::queue queue{ vecmem::sycl::device_selector() };
   std::cout << "Using device:" << std::endl;
   std::cout << "    name: "
             << queue.get_device().get_info< cl::sycl::info::device::name >()
             << std::endl;
   std::cout << "  vendor: "
             << queue.get_device().get_info< cl::sycl::info::device::vendor >()
             << std::endl;
   std::cout << " version: "
             << queue.get_device().get_info< cl::sycl::info::device::version >()
             << std::endl;

   // Set up the memory resource for the test.
   vecmem::sycl::shared_memory_resource resource( &queue );

   // Create an input and an output vector.
   auto inputvec = make_input_vector( resource );
   auto outputvec = make_output_vector( resource );
   assert( inputvec.size() == outputvec.size() );

   // Create the array that is used in the linear transformation.
   vecmem::array< int, 2 > constantsarray( &resource );
   constantsarray[ 0 ] = 2;
   constantsarray[ 1 ] = 3;

   // Perform a linear transformation using the vecmem vector helper types.
   queue.submit( [ &constantsarray, &inputvec,
                   &outputvec ]( cl::sycl::handler& h ) {

      // Translate the host containers to simple types.
      auto constants = vecmem::get_data( constantsarray );
      auto input = vecmem::get_data( inputvec );
      auto output = vecmem::get_data( outputvec );

      // Run the kernel.
      h.parallel_for< class LinearTransform >(
         cl::sycl::range< 1 >( inputvec.size() ),
         [ constants, input, output ]( cl::sycl::id< 1 > id ) {

            // Skip invalid indices.
            if( id >= input.m_size ) {
               return;
            }

            // Create the helper containers.
            const vecmem::const_device_array< int, 2 >
               constantarray( constants );
            const vecmem::const_device_vector< int > inputvec( input );
            vecmem::device_vector< int > outputvec( output );

            // Perform the linear transformation.
            outputvec.at( id ) = inputvec.at( id ) * constantarray.at( 0 ) +
                                 constantarray.at( 1 );
            return;
         } );
   } );
   queue.wait();

   // Check the output.
   for( std::size_t i = 0; i < outputvec.size(); ++i ) {
      assert( outputvec.at( i ) == inputvec.at( i ) * constantsarray.at( 0 ) +
                                   constantsarray.at( 1 ) );
   }

   // Return gracefully.
   return 0;
}
