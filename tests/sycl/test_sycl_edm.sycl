/* VecMem project, part of the ACTS project (R&D line)
 *
 * (c) 2023 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL include(s).
#include <CL/sycl.hpp>

// Local include(s).
#include "../common/edm_simple_container.hpp"
#include "../common/edm_simple_container_helpers.hpp"
#include "vecmem/memory/sycl/device_memory_resource.hpp"
#include "vecmem/memory/sycl/host_memory_resource.hpp"
#include "vecmem/memory/sycl/shared_memory_resource.hpp"
#include "vecmem/utils/sycl/copy.hpp"

// GoogleTest include(s).
#include <gtest/gtest.h>

/// Test fixture for the SYCL EDM tests
class sycl_edm_test : public testing::Test {

protected:
    /// SYCL queue to use
    cl::sycl::queue m_queue;

    /// Host memory resource
    vecmem::sycl::host_memory_resource m_host_mr{&m_queue};
    /// Device memory resource
    vecmem::sycl::device_memory_resource m_device_mr{&m_queue};
    /// Shared memory resource
    vecmem::sycl::shared_memory_resource m_shared_mr{&m_queue};

    /// Helper object for performing (SYCL) memory copies
    vecmem::sycl::copy m_copy{&m_queue};

};  // class sycl_edm_test

/// Convenience type declaration
using test_edm = vecmem::testing::simple_container;

/// Helper function for modifying the data in a container
void modify(unsigned int i, test_edm::device& device) {

    // In the first thread modify the scalars.
    if (i == 0) {
        test_edm::count::get(device) += 2;
        test_edm::average::get(device) -= 1.0f;
    }
    // In the rest of the threads modify the vector variables.
    if (i < device.size()) {
        test_edm::measurement::get(device)[i] *= 2.0f;
        test_edm::index::get(device)[i] += 10;
    }
}

TEST_F(sycl_edm_test, modify_host) {

    // Create two host containers in host and shared memory.
    test_edm::host container1{m_host_mr};
    test_edm::host container2{m_shared_mr};

    // Fill them with some data.
    vecmem::testing::fill(container1);
    vecmem::testing::fill(container2);

    // Modify the container in host memory, using a simple for loop.
    test_edm::device device1 = vecmem::get_data(container1);
    for (unsigned int i = 0; i < container1.size(); ++i) {
        modify(i, device1);
    }

    // Run a kernel that executes the modify function on the host object.
    m_queue
        .submit([&container2](cl::sycl::handler& h) {
            h.parallel_for<class edm_modify_host>(
                cl::sycl::range<1>{container2.size()},
                [view = vecmem::get_data(container2)](cl::sycl::id<1> id) {
                    test_edm::device device2{view};
                    modify(id[0], device2);
                });
        })
        .wait_and_throw();

    // Compare the two.
    vecmem::testing::compare(container1, container2);
}

TEST_F(sycl_edm_test, modify_device) {

    // Create a host container in host memory as a start.
    test_edm::host container1{m_host_mr};

    // Fill it with some data.
    vecmem::testing::fill(container1);

    // Copy it to the device.
    test_edm::buffer buffer{
        static_cast<test_edm::buffer::size_type>(container1.size()),
        m_device_mr};
    m_copy.setup(buffer);
    m_copy(vecmem::get_data(container1), buffer,
           vecmem::copy::type::host_to_device);

    // Modify the container in host memory, using a simple for loop.
    test_edm::device device1 = vecmem::get_data(container1);
    for (unsigned int i = 0; i < container1.size(); ++i) {
        modify(i, device1);
    }

    // Run a kernel that executes the modify function on the device buffer.
    m_queue
        .submit([&buffer](cl::sycl::handler& h) {
            h.parallel_for<class edm_modify_device>(
                cl::sycl::range<1>{buffer.size()},
                [view = vecmem::get_data(buffer)](cl::sycl::id<1> id) {
                    test_edm::device device2{view};
                    modify(id[0], device2);
                });
        })
        .wait_and_throw();

    // Copy the data back to the host.
    test_edm::host container2{m_host_mr};
    m_copy(buffer, container2);

    // Compare the two.
    vecmem::testing::compare(container1, container2);
}

/// Helper function for filling data into a device container
void fill(unsigned int i, test_edm::device& device) {

    // In the first thread modify the scalars.
    if (i == 0) {
        test_edm::count::get(device) = 55;
        test_edm::average::get(device) = 3.141592f;
    }
    // In the rest of the threads modify the vector variables.
    if (i < device.size()) {
        test_edm::measurement::get(device)[i] = 1.0f * static_cast<float>(i);
        test_edm::index::get(device)[i] = static_cast<int>(i);
    }
}

TEST_F(sycl_edm_test, fill_device) {

    // Container sizes to create on the host and the device.
    static constexpr unsigned int CONTAINER_SIZE = 10000;

    // Create a host container, and fill it.
    test_edm::host container1{m_host_mr};
    container1.resize(CONTAINER_SIZE);
    test_edm::device device1{vecmem::get_data(container1)};
    for (unsigned int i = 0; i < container1.size(); ++i) {
        fill(i, device1);
    }

    // Create a resizable device buffer.
    test_edm::buffer buffer{CONTAINER_SIZE, m_device_mr,
                            vecmem::data::buffer_type::resizable};
    m_copy.setup(buffer);

    // Run a kernel that fills the buffer.
    m_queue
        .submit([&buffer](cl::sycl::handler& h) {
            h.parallel_for<class edm_fill_device>(
                cl::sycl::range<1>{buffer.capacity()},
                [view = vecmem::get_data(buffer)](cl::sycl::id<1> id) {
                    test_edm::device device2{view};
                    if (id[0] < device2.capacity()) {
                        test_edm::device::size_type ii =
                            device2.push_back_default();
                        fill(ii, device2);
                    }
                });
        })
        .wait_and_throw();

    // Copy the device buffer back to the host.
    test_edm::host container2{m_host_mr};
    m_copy(buffer, container2);

    // Compare the two containers.
    vecmem::testing::compare(container1, container2);
}
